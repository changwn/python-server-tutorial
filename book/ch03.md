# 多进程模型

多进程模型是为了解决单个进程既要执行监听工作，又要执行新 socket 的数据传输工作，一人分饰两个角色的低效问题。

是的，多进程模型能够解决这种问题。

**那试试多进程如何？**

<!-- more -->

显然这样的模型是低效的，而计算机代表的可是生产力工具

是啊，多进程看上去是个好办法，每当 socket 收到一个新的请求，fork 一个进程来处理这个新的请求，原有的进程就不必等待处理工作完成之后再去监听新的连接对话。在 linux 中 fork 出来的进程和父进程拥有同样的上下文信息、内存数据、与进程关联的文件描述符等，不同的是这两个进程完全是在两个不同的虚拟内存段上，相互不干扰， 而 socket 不正是一个文件描述符么？


**多进程 sample**


```python

# process A
# create tcp client
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# enable reuse address port
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
# bind socket to the port
server_address = (host, port)
s.bind(server_address)
s.listen(backlog)
while 1:
    print 'waitting to recevie message from client'
    client, address = s.accept()
    pid = os.fork()
    if pid:
        continue
    else:
        # process work in child process
        pass
        client.close()
        sys.exit(0)
```

很简单是不是，处理工作和监听请求现在是分开的，这样进程 A 可以同时处理多个对话了（对我们人类来说几乎可以认为是同时了：）。


如果某些情况下，需要让**负责监听的进程**和**处理工作的进程**也进行**交流**，那他们是不是也需要再进行 socket 会话呢，事情变得麻烦了是不是。而且还有一点是只要多一个进程处理，计算机就要分配相应的资源对进程进行管理，而且进程的上下文切换是昂贵的，每次切换都需要做数据栈保存、恢复、进行系统调用中断、用户区到内核区相互数据 copy，真的是有很多工作要做。


还有其他办法么？除了进程可以让计算机同时做很多工作以外，**线程**也是可以的，而且线程是进程内部的子程序，线程之间共享相同的内存区域，他们很容易就可以进行交流，线程之间的切换完全发生在进程内部。


**多线程 sample**

```python

# process A
# create tcp client
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# enable reuse address port
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
# bind socket to the port
server_address = (host, port)
s.bind(server_address)
s.listen(backlog)
while 1:
    print 'waitting to recevie message from client'
    client, address = s.accept()
    thread = thread.Thread(target=func, args=(client, address))
    thread.start()
```


任何模型都不是完美的，线程的问题又是什么？线程的问题在于**数据共享**，控制不同线程对数据的读写是一项有挑战的工作，如果要处理的业务逻辑本身就复杂，尤其是需要额外注意对数据的读写操作。而且不论进程模型或线程模型，都需要面临一个问题：不知道什么时候要去写数据或什么时候要去读数据。因为他们都没有办法确定数据什么时候到达。


于是 epoll 和 select 诞生了。（待续）