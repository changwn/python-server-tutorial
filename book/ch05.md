# IO multiplex: 走近 select

## 为什么需要 io 多路复用技术？

在多线程 web server 模型下由于线程的调度切换完全是由操作系统控制的，如果 socket 在某一时刻不可读或不可写导致调用阻塞引起线程被挂起，而 socket 何时可读何时可写都只能随机等待线程重新获取被调用的机会只会才能知道，还有一种做法就是设手动不断的检查来查看 socket 是否可读可写，然后再调用相应的工作线程进行处理，无论是哪种方式都将引入额外的开销，而且代码将变得非常复杂而且难以维护。


## 什么是 io 多路复用技术？

在非 io 多路复用技术的模型中，我们怎么得知有新的 socket 连接或者 socket 已经准备好读或写，只能是一直苦苦等待或者不断做轮询检查，而在 io 多路复用技术可以做到主动通知。

在 io 多路复用技术中，通过告知内核需要监听的 socket 以及对应的事件，由内核通知我们 socket 是否已经准备就绪，而不是不断的检查或做无用功。也就是说 io 多路复用技术是内核提供的一种功能，由于是被动通知，io 多路复用技术又称事件驱动，

## 讨论 io 多路复用技术用到的基础概念

- 阻塞
- 同步
- 异步
- 非阻塞

阻塞是指调用需要等待结果的完成，调用会影响后续指令的进行，可以认为计算机的任何调用都是阻塞的，因为不管什么调用都有 CPU 的执行等待，所以 阻塞是一个相对概念，只有在限定场景之下讨论阻塞才更有意义，比如一个请求涉及 5 个函数调用，请求的平均响应时间是 20 ms，分布到每个函数是 4 ms，如果某个函数调用时需要等待的时间导致请求的平均响应时间变长了，我们说这个函数是一个阻塞操作。

非阻塞，调用方式不影响后续的指令执行。

同步是指调用方需要等待结果的返回，然后才执行后续指令，不管等待时间的长短。

异步是指调用方不需要等待结果的返回，结果以通知的形式获得，真正的异步是需要在程序执行的每一步执行都需要时异步操作。


## 几种 io 模型

- blocking I/O
- nonblocking I/O
- I/O multiplexing (select and poll)
- signal driven I/O (SIGIO)
- asynchronous I/O (the POSIX aio_ functions)

阻塞 io 是指程序在遇到 io 调用时一直等待 io 就绪才会执行相应的指令，我们在前几章讨论的单进程模型，多线程模型都属于 recv 数据都属于阻塞 io，同步阻塞是最最简单的模型，socket 默认是阻塞的。

非阻塞 io，是指遇到 io 调用不管 io 有没有准备就绪（内核把数据拷贝到进程）都直接返回

io multiplex 是借助 select 和 poll 等内核提供的机制只在 io 准备就绪内核通知我们以后才进行 io 操作


信号驱动 io，同 io 多路复用技术，内核通过信号通知我们的 io 何时就绪。



## select 如何使用


linux 提供了几种函数 select/poll/epoll 实现 io 多路复用技术，我们先看看 select 是怎么使用的。

select 在 python select 模块 

```
select.select(rlist, wlist, xlist[, timeout])

```

select 有 4 个参数，分别是读事件监听对象，写事件监听对象，异常事件对象，超时设置。

在 web server 中我们始终有一个 socket 是来监听的新的 socket 连接，因而这个监听 socket 要加入读事件队列。
